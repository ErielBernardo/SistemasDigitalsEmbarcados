
M¾dulo7SegmentDisplay.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000007dc  00008000  00008000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       00000040  000087dc  000087dc  000087dc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000004  0001081c  0001081c  0000881c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .comment      00000081  00000000  00000000  00008820  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000060  00000000  00000000  000088a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000001f1  00000000  00000000  00008901  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000ccc  00000000  00000000  00008af2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000002ce  00000000  00000000  000097be  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000003ad  00000000  00000000  00009a8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000318  00000000  00000000  00009e3c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004cb  00000000  00000000  0000a154  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000506  00000000  00000000  0000a61f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macinfo 0000ca9c  00000000  00000000  0000ab25  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .ARM.attributes 00000031  00000000  00000000  000175c1  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00008000 <__get_PSP>:
 * Return the actual process stack pointer
 */
uint32_t __get_PSP(void) __attribute__( ( naked ) );
uint32_t __get_PSP(void)
{
  uint32_t result=0;
    8000:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, psp\n\t" 
    8004:	f3ef 8409 	mrs	r4, PSP
    8008:	4620      	mov	r0, r4
    800a:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
    800c:	4623      	mov	r3, r4
}
    800e:	4618      	mov	r0, r3

00008010 <__set_PSP>:
 * Assign the value ProcessStackPointer to the MSP 
 * (process stack pointer) Cortex processor register
 */
void __set_PSP(uint32_t topOfProcStack) __attribute__( ( naked ) );
void __set_PSP(uint32_t topOfProcStack)
{
    8010:	4603      	mov	r3, r0
  __ASM volatile ("MSR psp, %0\n\t"
    8012:	f383 8809 	msr	PSP, r3
    8016:	4770      	bx	lr

00008018 <__get_MSP>:
 * Cortex processor register
 */
uint32_t __get_MSP(void) __attribute__( ( naked ) );
uint32_t __get_MSP(void)
{
  uint32_t result=0;
    8018:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, msp\n\t" 
    801c:	f3ef 8408 	mrs	r4, MSP
    8020:	4620      	mov	r0, r4
    8022:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
    8024:	4623      	mov	r3, r4
}
    8026:	4618      	mov	r0, r3

00008028 <__set_MSP>:
 * Assign the value mainStackPointer to the MSP 
 * (main stack pointer) Cortex processor register
 */
void __set_MSP(uint32_t topOfMainStack) __attribute__( ( naked ) );
void __set_MSP(uint32_t topOfMainStack)
{
    8028:	4603      	mov	r3, r0
  __ASM volatile ("MSR msp, %0\n\t"
    802a:	f383 8808 	msr	MSP, r3
    802e:	4770      	bx	lr

00008030 <__get_BASEPRI>:
 * @return BasePriority
 *
 * Return the content of the base priority register
 */
uint32_t __get_BASEPRI(void)
{
    8030:	b480      	push	{r7}
    8032:	b083      	sub	sp, #12
    8034:	af00      	add	r7, sp, #0
  uint32_t result=0;
    8036:	f04f 0300 	mov.w	r3, #0
    803a:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
    803c:	f3ef 8312 	mrs	r3, BASEPRI_MASK
    8040:	607b      	str	r3, [r7, #4]
  return(result);
    8042:	687b      	ldr	r3, [r7, #4]
}
    8044:	4618      	mov	r0, r3
    8046:	f107 070c 	add.w	r7, r7, #12
    804a:	46bd      	mov	sp, r7
    804c:	bc80      	pop	{r7}
    804e:	4770      	bx	lr

00008050 <__set_BASEPRI>:
 * @param  basePri  BasePriority
 *
 * Set the base priority register
 */
void __set_BASEPRI(uint32_t value)
{
    8050:	b480      	push	{r7}
    8052:	b083      	sub	sp, #12
    8054:	af00      	add	r7, sp, #0
    8056:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
    8058:	687b      	ldr	r3, [r7, #4]
    805a:	f383 8811 	msr	BASEPRI, r3
}
    805e:	f107 070c 	add.w	r7, r7, #12
    8062:	46bd      	mov	sp, r7
    8064:	bc80      	pop	{r7}
    8066:	4770      	bx	lr

00008068 <__get_PRIMASK>:
 * @return PriMask
 *
 * Return state of the priority mask bit from the priority mask register
 */
uint32_t __get_PRIMASK(void)
{
    8068:	b480      	push	{r7}
    806a:	b083      	sub	sp, #12
    806c:	af00      	add	r7, sp, #0
  uint32_t result=0;
    806e:	f04f 0300 	mov.w	r3, #0
    8072:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    8074:	f3ef 8310 	mrs	r3, PRIMASK
    8078:	607b      	str	r3, [r7, #4]
  return(result);
    807a:	687b      	ldr	r3, [r7, #4]
}
    807c:	4618      	mov	r0, r3
    807e:	f107 070c 	add.w	r7, r7, #12
    8082:	46bd      	mov	sp, r7
    8084:	bc80      	pop	{r7}
    8086:	4770      	bx	lr

00008088 <__set_PRIMASK>:
 * @param  priMask  PriMask
 *
 * Set the priority mask bit in the priority mask register
 */
void __set_PRIMASK(uint32_t priMask)
{
    8088:	b480      	push	{r7}
    808a:	b083      	sub	sp, #12
    808c:	af00      	add	r7, sp, #0
    808e:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
    8090:	687b      	ldr	r3, [r7, #4]
    8092:	f383 8810 	msr	PRIMASK, r3
}
    8096:	f107 070c 	add.w	r7, r7, #12
    809a:	46bd      	mov	sp, r7
    809c:	bc80      	pop	{r7}
    809e:	4770      	bx	lr

000080a0 <__get_FAULTMASK>:
 * @return FaultMask
 *
 * Return the content of the fault mask register
 */
uint32_t __get_FAULTMASK(void)
{
    80a0:	b480      	push	{r7}
    80a2:	b083      	sub	sp, #12
    80a4:	af00      	add	r7, sp, #0
  uint32_t result=0;
    80a6:	f04f 0300 	mov.w	r3, #0
    80aa:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
    80ac:	f3ef 8313 	mrs	r3, FAULTMASK
    80b0:	607b      	str	r3, [r7, #4]
  return(result);
    80b2:	687b      	ldr	r3, [r7, #4]
}
    80b4:	4618      	mov	r0, r3
    80b6:	f107 070c 	add.w	r7, r7, #12
    80ba:	46bd      	mov	sp, r7
    80bc:	bc80      	pop	{r7}
    80be:	4770      	bx	lr

000080c0 <__set_FAULTMASK>:
 * @param  faultMask  faultMask value
 *
 * Set the fault mask register
 */
void __set_FAULTMASK(uint32_t faultMask)
{
    80c0:	b480      	push	{r7}
    80c2:	b083      	sub	sp, #12
    80c4:	af00      	add	r7, sp, #0
    80c6:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
    80c8:	687b      	ldr	r3, [r7, #4]
    80ca:	f383 8813 	msr	FAULTMASK, r3
}
    80ce:	f107 070c 	add.w	r7, r7, #12
    80d2:	46bd      	mov	sp, r7
    80d4:	bc80      	pop	{r7}
    80d6:	4770      	bx	lr

000080d8 <__get_CONTROL>:
*  @return Control value
 *
 * Return the content of the control register
 */
uint32_t __get_CONTROL(void)
{
    80d8:	b480      	push	{r7}
    80da:	b083      	sub	sp, #12
    80dc:	af00      	add	r7, sp, #0
  uint32_t result=0;
    80de:	f04f 0300 	mov.w	r3, #0
    80e2:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, control" : "=r" (result) );
    80e4:	f3ef 8314 	mrs	r3, CONTROL
    80e8:	607b      	str	r3, [r7, #4]
  return(result);
    80ea:	687b      	ldr	r3, [r7, #4]
}
    80ec:	4618      	mov	r0, r3
    80ee:	f107 070c 	add.w	r7, r7, #12
    80f2:	46bd      	mov	sp, r7
    80f4:	bc80      	pop	{r7}
    80f6:	4770      	bx	lr

000080f8 <__set_CONTROL>:
 * @param  control  Control value
 *
 * Set the control register
 */
void __set_CONTROL(uint32_t control)
{
    80f8:	b480      	push	{r7}
    80fa:	b083      	sub	sp, #12
    80fc:	af00      	add	r7, sp, #0
    80fe:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR control, %0" : : "r" (control) );
    8100:	687b      	ldr	r3, [r7, #4]
    8102:	f383 8814 	msr	CONTROL, r3
}
    8106:	f107 070c 	add.w	r7, r7, #12
    810a:	46bd      	mov	sp, r7
    810c:	bc80      	pop	{r7}
    810e:	4770      	bx	lr

00008110 <__REV>:
 * @return        reversed value
 *
 * Reverse byte order in integer value
 */
uint32_t __REV(uint32_t value)
{
    8110:	b480      	push	{r7}
    8112:	b085      	sub	sp, #20
    8114:	af00      	add	r7, sp, #0
    8116:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
    8118:	f04f 0300 	mov.w	r3, #0
    811c:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
    811e:	687b      	ldr	r3, [r7, #4]
    8120:	ba1b      	rev	r3, r3
    8122:	60fb      	str	r3, [r7, #12]
  return(result);
    8124:	68fb      	ldr	r3, [r7, #12]
}
    8126:	4618      	mov	r0, r3
    8128:	f107 0714 	add.w	r7, r7, #20
    812c:	46bd      	mov	sp, r7
    812e:	bc80      	pop	{r7}
    8130:	4770      	bx	lr
    8132:	bf00      	nop

00008134 <__REV16>:
 * @return        reversed value
 *
 * Reverse byte order in unsigned short value
 */
uint32_t __REV16(uint16_t value)
{
    8134:	b480      	push	{r7}
    8136:	b085      	sub	sp, #20
    8138:	af00      	add	r7, sp, #0
    813a:	4603      	mov	r3, r0
    813c:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
    813e:	f04f 0300 	mov.w	r3, #0
    8142:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
    8144:	88fb      	ldrh	r3, [r7, #6]
    8146:	ba5b      	rev16	r3, r3
    8148:	60fb      	str	r3, [r7, #12]
  return(result);
    814a:	68fb      	ldr	r3, [r7, #12]
}
    814c:	4618      	mov	r0, r3
    814e:	f107 0714 	add.w	r7, r7, #20
    8152:	46bd      	mov	sp, r7
    8154:	bc80      	pop	{r7}
    8156:	4770      	bx	lr

00008158 <__REVSH>:
 * @return        reversed value
 *
 * Reverse byte order in signed short value with sign extension to integer
 */
int32_t __REVSH(int16_t value)
{
    8158:	b480      	push	{r7}
    815a:	b085      	sub	sp, #20
    815c:	af00      	add	r7, sp, #0
    815e:	4603      	mov	r3, r0
    8160:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
    8162:	f04f 0300 	mov.w	r3, #0
    8166:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
    8168:	88fb      	ldrh	r3, [r7, #6]
    816a:	badb      	revsh	r3, r3
    816c:	60fb      	str	r3, [r7, #12]
  return(result);
    816e:	68fb      	ldr	r3, [r7, #12]
}
    8170:	4618      	mov	r0, r3
    8172:	f107 0714 	add.w	r7, r7, #20
    8176:	46bd      	mov	sp, r7
    8178:	bc80      	pop	{r7}
    817a:	4770      	bx	lr

0000817c <__RBIT>:
 * @return        reversed value
 *
 * Reverse bit order of value
 */
uint32_t __RBIT(uint32_t value)
{
    817c:	b480      	push	{r7}
    817e:	b085      	sub	sp, #20
    8180:	af00      	add	r7, sp, #0
    8182:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
    8184:	f04f 0300 	mov.w	r3, #0
    8188:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
    818a:	687b      	ldr	r3, [r7, #4]
    818c:	fa93 f3a3 	rbit	r3, r3
    8190:	60fb      	str	r3, [r7, #12]
   return(result);
    8192:	68fb      	ldr	r3, [r7, #12]
}
    8194:	4618      	mov	r0, r3
    8196:	f107 0714 	add.w	r7, r7, #20
    819a:	46bd      	mov	sp, r7
    819c:	bc80      	pop	{r7}
    819e:	4770      	bx	lr

000081a0 <__LDREXB>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 8 bit value
 */
uint8_t __LDREXB(uint8_t *addr)
{
    81a0:	b480      	push	{r7}
    81a2:	b085      	sub	sp, #20
    81a4:	af00      	add	r7, sp, #0
    81a6:	6078      	str	r0, [r7, #4]
    uint8_t result=0;
    81a8:	f04f 0300 	mov.w	r3, #0
    81ac:	73fb      	strb	r3, [r7, #15]
  
   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
    81ae:	687b      	ldr	r3, [r7, #4]
    81b0:	e8d3 3f4f 	ldrexb	r3, [r3]
    81b4:	73fb      	strb	r3, [r7, #15]
   return(result);
    81b6:	7bfb      	ldrb	r3, [r7, #15]
}
    81b8:	4618      	mov	r0, r3
    81ba:	f107 0714 	add.w	r7, r7, #20
    81be:	46bd      	mov	sp, r7
    81c0:	bc80      	pop	{r7}
    81c2:	4770      	bx	lr

000081c4 <__LDREXH>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 16 bit values
 */
uint16_t __LDREXH(uint16_t *addr)
{
    81c4:	b480      	push	{r7}
    81c6:	b085      	sub	sp, #20
    81c8:	af00      	add	r7, sp, #0
    81ca:	6078      	str	r0, [r7, #4]
    uint16_t result=0;
    81cc:	f04f 0300 	mov.w	r3, #0
    81d0:	81fb      	strh	r3, [r7, #14]
  
   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
    81d2:	687b      	ldr	r3, [r7, #4]
    81d4:	e8d3 3f5f 	ldrexh	r3, [r3]
    81d8:	81fb      	strh	r3, [r7, #14]
   return(result);
    81da:	89fb      	ldrh	r3, [r7, #14]
}
    81dc:	4618      	mov	r0, r3
    81de:	f107 0714 	add.w	r7, r7, #20
    81e2:	46bd      	mov	sp, r7
    81e4:	bc80      	pop	{r7}
    81e6:	4770      	bx	lr

000081e8 <__LDREXW>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 32 bit values
 */
uint32_t __LDREXW(uint32_t *addr)
{
    81e8:	b480      	push	{r7}
    81ea:	b085      	sub	sp, #20
    81ec:	af00      	add	r7, sp, #0
    81ee:	6078      	str	r0, [r7, #4]
    uint32_t result=0;
    81f0:	f04f 0300 	mov.w	r3, #0
    81f4:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    81f6:	687b      	ldr	r3, [r7, #4]
    81f8:	e853 3f00 	ldrex	r3, [r3]
    81fc:	60fb      	str	r3, [r7, #12]
   return(result);
    81fe:	68fb      	ldr	r3, [r7, #12]
}
    8200:	4618      	mov	r0, r3
    8202:	f107 0714 	add.w	r7, r7, #20
    8206:	46bd      	mov	sp, r7
    8208:	bc80      	pop	{r7}
    820a:	4770      	bx	lr

0000820c <__STREXB>:
 * @return        successful / failed
 *
 * Exclusive STR command for 8 bit values
 */
uint32_t __STREXB(uint8_t value, uint8_t *addr)
{
    820c:	b480      	push	{r7}
    820e:	b085      	sub	sp, #20
    8210:	af00      	add	r7, sp, #0
    8212:	4603      	mov	r3, r0
    8214:	6039      	str	r1, [r7, #0]
    8216:	71fb      	strb	r3, [r7, #7]
   uint32_t result=0;
    8218:	f04f 0300 	mov.w	r3, #0
    821c:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
    821e:	683b      	ldr	r3, [r7, #0]
    8220:	79fa      	ldrb	r2, [r7, #7]
    8222:	e8c3 2f43 	strexb	r3, r2, [r3]
    8226:	60fb      	str	r3, [r7, #12]
   return(result);
    8228:	68fb      	ldr	r3, [r7, #12]
}
    822a:	4618      	mov	r0, r3
    822c:	f107 0714 	add.w	r7, r7, #20
    8230:	46bd      	mov	sp, r7
    8232:	bc80      	pop	{r7}
    8234:	4770      	bx	lr
    8236:	bf00      	nop

00008238 <__STREXH>:
 * @return        successful / failed
 *
 * Exclusive STR command for 16 bit values
 */
uint32_t __STREXH(uint16_t value, uint16_t *addr)
{
    8238:	b480      	push	{r7}
    823a:	b085      	sub	sp, #20
    823c:	af00      	add	r7, sp, #0
    823e:	4603      	mov	r3, r0
    8240:	6039      	str	r1, [r7, #0]
    8242:	80fb      	strh	r3, [r7, #6]
   uint32_t result=0;
    8244:	f04f 0300 	mov.w	r3, #0
    8248:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
    824a:	683b      	ldr	r3, [r7, #0]
    824c:	88fa      	ldrh	r2, [r7, #6]
    824e:	e8c3 2f53 	strexh	r3, r2, [r3]
    8252:	60fb      	str	r3, [r7, #12]
   return(result);
    8254:	68fb      	ldr	r3, [r7, #12]
}
    8256:	4618      	mov	r0, r3
    8258:	f107 0714 	add.w	r7, r7, #20
    825c:	46bd      	mov	sp, r7
    825e:	bc80      	pop	{r7}
    8260:	4770      	bx	lr
    8262:	bf00      	nop

00008264 <__STREXW>:
 * @return        successful / failed
 *
 * Exclusive STR command for 32 bit values
 */
uint32_t __STREXW(uint32_t value, uint32_t *addr)
{
    8264:	b480      	push	{r7}
    8266:	b085      	sub	sp, #20
    8268:	af00      	add	r7, sp, #0
    826a:	6078      	str	r0, [r7, #4]
    826c:	6039      	str	r1, [r7, #0]
   uint32_t result=0;
    826e:	f04f 0300 	mov.w	r3, #0
    8272:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
    8274:	683b      	ldr	r3, [r7, #0]
    8276:	687a      	ldr	r2, [r7, #4]
    8278:	e843 2300 	strex	r3, r2, [r3]
    827c:	60fb      	str	r3, [r7, #12]
   return(result);
    827e:	68fb      	ldr	r3, [r7, #12]
}
    8280:	4618      	mov	r0, r3
    8282:	f107 0714 	add.w	r7, r7, #20
    8286:	46bd      	mov	sp, r7
    8288:	bc80      	pop	{r7}
    828a:	4770      	bx	lr

0000828c <SSeg_Config>:

// Function to provide short delay
void short_delay (int n);

// Configurando os pinos que estão ligados aos leds
void SSeg_Config(void){
    828c:	b480      	push	{r7}
    828e:	af00      	add	r7, sp, #0

  LPC_GPIO0->FIODIR = 0x00000ff0;
    8290:	f24c 0300 	movw	r3, #49152	; 0xc000
    8294:	f2c2 0309 	movt	r3, #8201	; 0x2009
    8298:	f44f 627f 	mov.w	r2, #4080	; 0xff0
    829c:	601a      	str	r2, [r3, #0]
  LPC_GPIO3->FIODIR = 0xffffffff;
    829e:	f24c 0360 	movw	r3, #49248	; 0xc060
    82a2:	f2c2 0309 	movt	r3, #8201	; 0x2009
    82a6:	f04f 32ff 	mov.w	r2, #4294967295
    82aa:	601a      	str	r2, [r3, #0]
  LPC_GPIO4->FIODIR = 0xffffffff;
    82ac:	f24c 0380 	movw	r3, #49280	; 0xc080
    82b0:	f2c2 0309 	movt	r3, #8201	; 0x2009
    82b4:	f04f 32ff 	mov.w	r2, #4294967295
    82b8:	601a      	str	r2, [r3, #0]
}
    82ba:	46bd      	mov	sp, r7
    82bc:	bc80      	pop	{r7}
    82be:	4770      	bx	lr

000082c0 <SSegWrite>:

void SSegWrite(unsigned char number){
    82c0:	b490      	push	{r4, r7}
    82c2:	b092      	sub	sp, #72	; 0x48
    82c4:	af00      	add	r7, sp, #0
    82c6:	4603      	mov	r3, r0
    82c8:	71fb      	strb	r3, [r7, #7]
	unsigned int SSegChar[] = {0xf3ff/*0*/,0xf06f/*1*/,0xf5bf/*2*/,0xf4ff/*3*/
							  ,0xf66f/*4*/,0xf6Df/*5*/,0xf7cf/*6*/,0xf07f/*7*/
							  ,0xf7ff/*8*/,0xf67f/*9*/,0xf77f/*A*/,0xf7cf/*B*/
							  ,0xf39f/*C*/,0xf5ef/*D*/,0xf79f/*E*/,0xf71f/*F*/};
    82ca:	f248 73dc 	movw	r3, #34780	; 0x87dc
    82ce:	f2c0 0300 	movt	r3, #0
    82d2:	f107 0c08 	add.w	ip, r7, #8
    82d6:	461c      	mov	r4, r3
    82d8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    82da:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    82de:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    82e0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    82e4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
    82e6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
    82ea:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
    82ee:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
	LPC_GPIO0->FIOPINL =  (SSegChar[number]);
    82f2:	f24c 0300 	movw	r3, #49152	; 0xc000
    82f6:	f2c2 0309 	movt	r3, #8201	; 0x2009
    82fa:	79fa      	ldrb	r2, [r7, #7]
    82fc:	ea4f 0282 	mov.w	r2, r2, lsl #2
    8300:	f107 0148 	add.w	r1, r7, #72	; 0x48
    8304:	440a      	add	r2, r1
    8306:	f852 2c40 	ldr.w	r2, [r2, #-64]
    830a:	b292      	uxth	r2, r2
    830c:	829a      	strh	r2, [r3, #20]
}
    830e:	f107 0748 	add.w	r7, r7, #72	; 0x48
    8312:	46bd      	mov	sp, r7
    8314:	bc90      	pop	{r4, r7}
    8316:	4770      	bx	lr

00008318 <short_delay>:

void short_delay(int n)
{
    8318:	b480      	push	{r7}
    831a:	b085      	sub	sp, #20
    831c:	af00      	add	r7, sp, #0
    831e:	6078      	str	r0, [r7, #4]
   volatile int d;
   for (d=0; d<n*3000; d++){}
    8320:	f04f 0300 	mov.w	r3, #0
    8324:	60fb      	str	r3, [r7, #12]
    8326:	e003      	b.n	8330 <short_delay+0x18>
    8328:	68fb      	ldr	r3, [r7, #12]
    832a:	f103 0301 	add.w	r3, r3, #1
    832e:	60fb      	str	r3, [r7, #12]
    8330:	687b      	ldr	r3, [r7, #4]
    8332:	f640 32b8 	movw	r2, #3000	; 0xbb8
    8336:	fb02 f203 	mul.w	r2, r2, r3
    833a:	68fb      	ldr	r3, [r7, #12]
    833c:	429a      	cmp	r2, r3
    833e:	dcf3      	bgt.n	8328 <short_delay+0x10>
}
    8340:	f107 0714 	add.w	r7, r7, #20
    8344:	46bd      	mov	sp, r7
    8346:	bc80      	pop	{r7}
    8348:	4770      	bx	lr
    834a:	bf00      	nop

0000834c <main>:

// MAIN function
int main(void) {
    834c:	b580      	push	{r7, lr}
    834e:	b082      	sub	sp, #8
    8350:	af00      	add	r7, sp, #0

	// Declarando variáveis
	unsigned char counter;
	
	// Set up board/processor
	SystemInit();
    8352:	f000 f939 	bl	85c8 <SystemInit>

	// Configurando Display de Sete Segmentos... 
	SSeg_Config();
    8356:	f7ff ff99 	bl	828c <SSeg_Config>

	LPC_GPIO4->FIOPIN = 0xf0000000;
    835a:	f24c 0380 	movw	r3, #49280	; 0xc080
    835e:	f2c2 0309 	movt	r3, #8201	; 0x2009
    8362:	f04f 4270 	mov.w	r2, #4026531840	; 0xf0000000
    8366:	615a      	str	r2, [r3, #20]
	LPC_GPIO3->FIOPIN = 0x0f000000;
    8368:	f24c 0360 	movw	r3, #49248	; 0xc060
    836c:	f2c2 0309 	movt	r3, #8201	; 0x2009
    8370:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
    8374:	615a      	str	r2, [r3, #20]

	while(1)
	{
		for (counter = 0; counter < 16; counter++)
    8376:	f04f 0300 	mov.w	r3, #0
    837a:	71fb      	strb	r3, [r7, #7]
    837c:	e00b      	b.n	8396 <main+0x4a>
      	{
      		SSegWrite(counter);
    837e:	79fb      	ldrb	r3, [r7, #7]
    8380:	4618      	mov	r0, r3
    8382:	f7ff ff9d 	bl	82c0 <SSegWrite>
			short_delay(2000);
    8386:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
    838a:	f7ff ffc5 	bl	8318 <short_delay>
	LPC_GPIO4->FIOPIN = 0xf0000000;
	LPC_GPIO3->FIOPIN = 0x0f000000;

	while(1)
	{
		for (counter = 0; counter < 16; counter++)
    838e:	79fb      	ldrb	r3, [r7, #7]
    8390:	f103 0301 	add.w	r3, r3, #1
    8394:	71fb      	strb	r3, [r7, #7]
    8396:	79fb      	ldrb	r3, [r7, #7]
    8398:	2b0f      	cmp	r3, #15
    839a:	d9f0      	bls.n	837e <main+0x32>
      	{
      		SSegWrite(counter);
			short_delay(2000);
		}
	}
    839c:	e7eb      	b.n	8376 <main+0x2a>
    839e:	bf00      	nop

000083a0 <SystemCoreClockUpdate>:

/*----------------------------------------------------------------------------
  Clock functions
 *----------------------------------------------------------------------------*/
void SystemCoreClockUpdate (void)            /* Get Core Clock Frequency      */
{
    83a0:	b480      	push	{r7}
    83a2:	af00      	add	r7, sp, #0
  /* Determine clock frequency according to clock register values             */
  if (((LPC_SC->PLL0STAT >> 24) & 3) == 3) { /* If PLL0 enabled and connected */
    83a4:	f24c 0300 	movw	r3, #49152	; 0xc000
    83a8:	f2c4 030f 	movt	r3, #16399	; 0x400f
    83ac:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    83b0:	ea4f 6313 	mov.w	r3, r3, lsr #24
    83b4:	f003 0303 	and.w	r3, r3, #3
    83b8:	2b03      	cmp	r3, #3
    83ba:	f040 80ac 	bne.w	8516 <SystemCoreClockUpdate+0x176>
    switch (LPC_SC->CLKSRCSEL & 0x03) {
    83be:	f24c 0300 	movw	r3, #49152	; 0xc000
    83c2:	f2c4 030f 	movt	r3, #16399	; 0x400f
    83c6:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
    83ca:	f003 0303 	and.w	r3, r3, #3
    83ce:	2b03      	cmp	r3, #3
    83d0:	f200 80f6 	bhi.w	85c0 <SystemCoreClockUpdate+0x220>
    83d4:	a201      	add	r2, pc, #4	; (adr r2, 83dc <SystemCoreClockUpdate+0x3c>)
    83d6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    83da:	bf00      	nop
    83dc:	000083ed 	.word	0x000083ed
    83e0:	00008451 	.word	0x00008451
    83e4:	000084b7 	.word	0x000084b7
    83e8:	000083ed 	.word	0x000083ed
      case 0:                                /* Int. RC oscillator => PLL0    */
      case 3:                                /* Reserved, default to Int. RC  */
        SystemCoreClock = (IRC_OSC * 
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
    83ec:	f24c 0300 	movw	r3, #49152	; 0xc000
    83f0:	f2c4 030f 	movt	r3, #16399	; 0x400f
    83f4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    83f8:	ea4f 4343 	mov.w	r3, r3, lsl #17
    83fc:	ea4f 4353 	mov.w	r3, r3, lsr #17
    8400:	f103 0201 	add.w	r2, r3, #1
    8404:	f241 2300 	movw	r3, #4608	; 0x1200
    8408:	f2c0 037a 	movt	r3, #122	; 0x7a
    840c:	fb03 f202 	mul.w	r2, r3, r2
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
    8410:	f24c 0300 	movw	r3, #49152	; 0xc000
    8414:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8418:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    841c:	ea4f 4313 	mov.w	r3, r3, lsr #16
    8420:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    8424:	f103 0301 	add.w	r3, r3, #1
    8428:	fbb2 f2f3 	udiv	r2, r2, r3
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
    842c:	f24c 0300 	movw	r3, #49152	; 0xc000
    8430:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8434:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    8438:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    843c:	f103 0301 	add.w	r3, r3, #1
  /* Determine clock frequency according to clock register values             */
  if (((LPC_SC->PLL0STAT >> 24) & 3) == 3) { /* If PLL0 enabled and connected */
    switch (LPC_SC->CLKSRCSEL & 0x03) {
      case 0:                                /* Int. RC oscillator => PLL0    */
      case 3:                                /* Reserved, default to Int. RC  */
        SystemCoreClock = (IRC_OSC * 
    8440:	fbb2 f2f3 	udiv	r2, r2, r3
    8444:	f640 031c 	movw	r3, #2076	; 0x81c
    8448:	f2c0 0301 	movt	r3, #1
    844c:	601a      	str	r2, [r3, #0]
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
    844e:	e0b8      	b.n	85c2 <SystemCoreClockUpdate+0x222>
      case 1:                                /* Main oscillator => PLL0       */
        SystemCoreClock = (OSC_CLK * 
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
    8450:	f24c 0300 	movw	r3, #49152	; 0xc000
    8454:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8458:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    845c:	ea4f 4343 	mov.w	r3, r3, lsl #17
    8460:	ea4f 4353 	mov.w	r3, r3, lsr #17
    8464:	f103 0201 	add.w	r2, r3, #1
    8468:	f243 6300 	movw	r3, #13824	; 0x3600
    846c:	f2c0 136e 	movt	r3, #366	; 0x16e
    8470:	fb03 f202 	mul.w	r2, r3, r2
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
    8474:	f24c 0300 	movw	r3, #49152	; 0xc000
    8478:	f2c4 030f 	movt	r3, #16399	; 0x400f
    847c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    8480:	ea4f 4313 	mov.w	r3, r3, lsr #16
    8484:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    8488:	f103 0301 	add.w	r3, r3, #1
    848c:	fbb2 f2f3 	udiv	r2, r2, r3
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
    8490:	f24c 0300 	movw	r3, #49152	; 0xc000
    8494:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8498:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    849c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    84a0:	f103 0301 	add.w	r3, r3, #1
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
      case 1:                                /* Main oscillator => PLL0       */
        SystemCoreClock = (OSC_CLK * 
    84a4:	fbb2 f2f3 	udiv	r2, r2, r3
    84a8:	f640 031c 	movw	r3, #2076	; 0x81c
    84ac:	f2c0 0301 	movt	r3, #1
    84b0:	601a      	str	r2, [r3, #0]
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
    84b2:	bf00      	nop
    84b4:	e085      	b.n	85c2 <SystemCoreClockUpdate+0x222>
      case 2:                                /* RTC oscillator => PLL0        */
        SystemCoreClock = (RTC_CLK * 
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
    84b6:	f24c 0300 	movw	r3, #49152	; 0xc000
    84ba:	f2c4 030f 	movt	r3, #16399	; 0x400f
    84be:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    84c2:	ea4f 4343 	mov.w	r3, r3, lsl #17
    84c6:	ea4f 4353 	mov.w	r3, r3, lsr #17
    84ca:	f103 0301 	add.w	r3, r3, #1
    84ce:	f44f 427a 	mov.w	r2, #64000	; 0xfa00
    84d2:	fb02 f203 	mul.w	r2, r2, r3
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
    84d6:	f24c 0300 	movw	r3, #49152	; 0xc000
    84da:	f2c4 030f 	movt	r3, #16399	; 0x400f
    84de:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    84e2:	ea4f 4313 	mov.w	r3, r3, lsr #16
    84e6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    84ea:	f103 0301 	add.w	r3, r3, #1
    84ee:	fbb2 f2f3 	udiv	r2, r2, r3
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
    84f2:	f24c 0300 	movw	r3, #49152	; 0xc000
    84f6:	f2c4 030f 	movt	r3, #16399	; 0x400f
    84fa:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    84fe:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    8502:	f103 0301 	add.w	r3, r3, #1
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
      case 2:                                /* RTC oscillator => PLL0        */
        SystemCoreClock = (RTC_CLK * 
    8506:	fbb2 f2f3 	udiv	r2, r2, r3
    850a:	f640 031c 	movw	r3, #2076	; 0x81c
    850e:	f2c0 0301 	movt	r3, #1
    8512:	601a      	str	r2, [r3, #0]
    8514:	e055      	b.n	85c2 <SystemCoreClockUpdate+0x222>
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
    }
  } else {
    switch (LPC_SC->CLKSRCSEL & 0x03) {
    8516:	f24c 0300 	movw	r3, #49152	; 0xc000
    851a:	f2c4 030f 	movt	r3, #16399	; 0x400f
    851e:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
    8522:	f003 0303 	and.w	r3, r3, #3
    8526:	2b03      	cmp	r3, #3
    8528:	d84b      	bhi.n	85c2 <SystemCoreClockUpdate+0x222>
    852a:	a201      	add	r2, pc, #4	; (adr r2, 8530 <SystemCoreClockUpdate+0x190>)
    852c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    8530:	00008541 	.word	0x00008541
    8534:	0000856d 	.word	0x0000856d
    8538:	00008599 	.word	0x00008599
    853c:	00008541 	.word	0x00008541
      case 0:                                /* Int. RC oscillator => PLL0    */
      case 3:                                /* Reserved, default to Int. RC  */
        SystemCoreClock = IRC_OSC / ((LPC_SC->CCLKCFG & 0xFF)+ 1);
    8540:	f24c 0300 	movw	r3, #49152	; 0xc000
    8544:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8548:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    854c:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    8550:	f103 0201 	add.w	r2, r3, #1
    8554:	f640 1300 	movw	r3, #2304	; 0x900
    8558:	f2c0 033d 	movt	r3, #61	; 0x3d
    855c:	fbb3 f2f2 	udiv	r2, r3, r2
    8560:	f640 031c 	movw	r3, #2076	; 0x81c
    8564:	f2c0 0301 	movt	r3, #1
    8568:	601a      	str	r2, [r3, #0]
        break;
    856a:	e02a      	b.n	85c2 <SystemCoreClockUpdate+0x222>
      case 1:                                /* Main oscillator => PLL0       */
        SystemCoreClock = OSC_CLK / ((LPC_SC->CCLKCFG & 0xFF)+ 1);
    856c:	f24c 0300 	movw	r3, #49152	; 0xc000
    8570:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8574:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    8578:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    857c:	f103 0201 	add.w	r2, r3, #1
    8580:	f641 3300 	movw	r3, #6912	; 0x1b00
    8584:	f2c0 03b7 	movt	r3, #183	; 0xb7
    8588:	fbb3 f2f2 	udiv	r2, r3, r2
    858c:	f640 031c 	movw	r3, #2076	; 0x81c
    8590:	f2c0 0301 	movt	r3, #1
    8594:	601a      	str	r2, [r3, #0]
        break;
    8596:	e014      	b.n	85c2 <SystemCoreClockUpdate+0x222>
      case 2:                                /* RTC oscillator => PLL0        */
        SystemCoreClock = RTC_CLK / ((LPC_SC->CCLKCFG & 0xFF)+ 1);
    8598:	f24c 0300 	movw	r3, #49152	; 0xc000
    859c:	f2c4 030f 	movt	r3, #16399	; 0x400f
    85a0:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
    85a4:	f003 03ff 	and.w	r3, r3, #255	; 0xff
    85a8:	f103 0301 	add.w	r3, r3, #1
    85ac:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
    85b0:	fbb2 f2f3 	udiv	r2, r2, r3
    85b4:	f640 031c 	movw	r3, #2076	; 0x81c
    85b8:	f2c0 0301 	movt	r3, #1
    85bc:	601a      	str	r2, [r3, #0]
    85be:	e000      	b.n	85c2 <SystemCoreClockUpdate+0x222>
                          ((2 * ((LPC_SC->PLL0STAT & 0x7FFF) + 1)))  /
                          (((LPC_SC->PLL0STAT >> 16) & 0xFF) + 1)    /
                          ((LPC_SC->CCLKCFG & 0xFF)+ 1));
        break;
      case 2:                                /* RTC oscillator => PLL0        */
        SystemCoreClock = (RTC_CLK * 
    85c0:	bf00      	nop
        SystemCoreClock = RTC_CLK / ((LPC_SC->CCLKCFG & 0xFF)+ 1);
        break;
    }
  }

}
    85c2:	46bd      	mov	sp, r7
    85c4:	bc80      	pop	{r7}
    85c6:	4770      	bx	lr

000085c8 <SystemInit>:
 *
 * @brief  Setup the microcontroller system.
 *         Initialize the System.
 */
void SystemInit (void)
{
    85c8:	b480      	push	{r7}
    85ca:	af00      	add	r7, sp, #0
#if (CLOCK_SETUP)                       /* Clock Setup                        */
  LPC_SC->SCS       = SCS_Val;
    85cc:	f24c 0300 	movw	r3, #49152	; 0xc000
    85d0:	f2c4 030f 	movt	r3, #16399	; 0x400f
    85d4:	f04f 0220 	mov.w	r2, #32
    85d8:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
  if (SCS_Val & (1 << 5)) {             /* If Main Oscillator is enabled      */
    while ((LPC_SC->SCS & (1<<6)) == 0);/* Wait for Oscillator to be ready    */
    85dc:	f24c 0300 	movw	r3, #49152	; 0xc000
    85e0:	f2c4 030f 	movt	r3, #16399	; 0x400f
    85e4:	f8d3 31a0 	ldr.w	r3, [r3, #416]	; 0x1a0
    85e8:	f003 0340 	and.w	r3, r3, #64	; 0x40
    85ec:	2b00      	cmp	r3, #0
    85ee:	d0f5      	beq.n	85dc <SystemInit+0x14>
  }

  LPC_SC->CCLKCFG   = CCLKCFG_Val;      /* Setup Clock Divider                */
    85f0:	f24c 0300 	movw	r3, #49152	; 0xc000
    85f4:	f2c4 030f 	movt	r3, #16399	; 0x400f
    85f8:	f04f 0203 	mov.w	r2, #3
    85fc:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104

#if (PLL0_SETUP)
  LPC_SC->CLKSRCSEL = CLKSRCSEL_Val;    /* Select Clock Source for PLL0       */
    8600:	f24c 0300 	movw	r3, #49152	; 0xc000
    8604:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8608:	f04f 0201 	mov.w	r2, #1
    860c:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c

  LPC_SC->PLL0CFG   = PLL0CFG_Val;      /* configure PLL0                     */
    8610:	f24c 0300 	movw	r3, #49152	; 0xc000
    8614:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8618:	f240 0263 	movw	r2, #99	; 0x63
    861c:	f2c0 0205 	movt	r2, #5
    8620:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  LPC_SC->PLL0FEED  = 0xAA;
    8624:	f24c 0300 	movw	r3, #49152	; 0xc000
    8628:	f2c4 030f 	movt	r3, #16399	; 0x400f
    862c:	f04f 02aa 	mov.w	r2, #170	; 0xaa
    8630:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  LPC_SC->PLL0FEED  = 0x55;
    8634:	f24c 0300 	movw	r3, #49152	; 0xc000
    8638:	f2c4 030f 	movt	r3, #16399	; 0x400f
    863c:	f04f 0255 	mov.w	r2, #85	; 0x55
    8640:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  LPC_SC->PLL0CON   = 0x01;             /* PLL0 Enable                        */
    8644:	f24c 0300 	movw	r3, #49152	; 0xc000
    8648:	f2c4 030f 	movt	r3, #16399	; 0x400f
    864c:	f04f 0201 	mov.w	r2, #1
    8650:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  LPC_SC->PLL0FEED  = 0xAA;
    8654:	f24c 0300 	movw	r3, #49152	; 0xc000
    8658:	f2c4 030f 	movt	r3, #16399	; 0x400f
    865c:	f04f 02aa 	mov.w	r2, #170	; 0xaa
    8660:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  LPC_SC->PLL0FEED  = 0x55;
    8664:	f24c 0300 	movw	r3, #49152	; 0xc000
    8668:	f2c4 030f 	movt	r3, #16399	; 0x400f
    866c:	f04f 0255 	mov.w	r2, #85	; 0x55
    8670:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  while (!(LPC_SC->PLL0STAT & (1<<26)));/* Wait for PLOCK0                    */
    8674:	f24c 0300 	movw	r3, #49152	; 0xc000
    8678:	f2c4 030f 	movt	r3, #16399	; 0x400f
    867c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    8680:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
    8684:	2b00      	cmp	r3, #0
    8686:	d0f5      	beq.n	8674 <SystemInit+0xac>

  LPC_SC->PLL0CON   = 0x03;             /* PLL0 Enable & Connect              */
    8688:	f24c 0300 	movw	r3, #49152	; 0xc000
    868c:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8690:	f04f 0203 	mov.w	r2, #3
    8694:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  LPC_SC->PLL0FEED  = 0xAA;
    8698:	f24c 0300 	movw	r3, #49152	; 0xc000
    869c:	f2c4 030f 	movt	r3, #16399	; 0x400f
    86a0:	f04f 02aa 	mov.w	r2, #170	; 0xaa
    86a4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  LPC_SC->PLL0FEED  = 0x55;
    86a8:	f24c 0300 	movw	r3, #49152	; 0xc000
    86ac:	f2c4 030f 	movt	r3, #16399	; 0x400f
    86b0:	f04f 0255 	mov.w	r2, #85	; 0x55
    86b4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  while (!(LPC_SC->PLL0STAT & ((1<<25) | (1<<24))));/* Wait for PLLC0_STAT & PLLE0_STAT */
    86b8:	f24c 0300 	movw	r3, #49152	; 0xc000
    86bc:	f2c4 030f 	movt	r3, #16399	; 0x400f
    86c0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    86c4:	f003 7340 	and.w	r3, r3, #50331648	; 0x3000000
    86c8:	2b00      	cmp	r3, #0
    86ca:	d0f5      	beq.n	86b8 <SystemInit+0xf0>
#endif

#if (PLL1_SETUP)
  LPC_SC->PLL1CFG   = PLL1CFG_Val;
    86cc:	f24c 0300 	movw	r3, #49152	; 0xc000
    86d0:	f2c4 030f 	movt	r3, #16399	; 0x400f
    86d4:	f04f 0223 	mov.w	r2, #35	; 0x23
    86d8:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  LPC_SC->PLL1FEED  = 0xAA;
    86dc:	f24c 0300 	movw	r3, #49152	; 0xc000
    86e0:	f2c4 030f 	movt	r3, #16399	; 0x400f
    86e4:	f04f 02aa 	mov.w	r2, #170	; 0xaa
    86e8:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  LPC_SC->PLL1FEED  = 0x55;
    86ec:	f24c 0300 	movw	r3, #49152	; 0xc000
    86f0:	f2c4 030f 	movt	r3, #16399	; 0x400f
    86f4:	f04f 0255 	mov.w	r2, #85	; 0x55
    86f8:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac

  LPC_SC->PLL1CON   = 0x01;             /* PLL1 Enable                        */
    86fc:	f24c 0300 	movw	r3, #49152	; 0xc000
    8700:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8704:	f04f 0201 	mov.w	r2, #1
    8708:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  LPC_SC->PLL1FEED  = 0xAA;
    870c:	f24c 0300 	movw	r3, #49152	; 0xc000
    8710:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8714:	f04f 02aa 	mov.w	r2, #170	; 0xaa
    8718:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  LPC_SC->PLL1FEED  = 0x55;
    871c:	f24c 0300 	movw	r3, #49152	; 0xc000
    8720:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8724:	f04f 0255 	mov.w	r2, #85	; 0x55
    8728:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  while (!(LPC_SC->PLL1STAT & (1<<10)));/* Wait for PLOCK1                    */
    872c:	f24c 0300 	movw	r3, #49152	; 0xc000
    8730:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8734:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
    8738:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    873c:	2b00      	cmp	r3, #0
    873e:	d0f5      	beq.n	872c <SystemInit+0x164>

  LPC_SC->PLL1CON   = 0x03;             /* PLL1 Enable & Connect              */
    8740:	f24c 0300 	movw	r3, #49152	; 0xc000
    8744:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8748:	f04f 0203 	mov.w	r2, #3
    874c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  LPC_SC->PLL1FEED  = 0xAA;
    8750:	f24c 0300 	movw	r3, #49152	; 0xc000
    8754:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8758:	f04f 02aa 	mov.w	r2, #170	; 0xaa
    875c:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  LPC_SC->PLL1FEED  = 0x55;
    8760:	f24c 0300 	movw	r3, #49152	; 0xc000
    8764:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8768:	f04f 0255 	mov.w	r2, #85	; 0x55
    876c:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  while (!(LPC_SC->PLL1STAT & ((1<< 9) | (1<< 8))));/* Wait for PLLC1_STAT & PLLE1_STAT */
    8770:	f24c 0300 	movw	r3, #49152	; 0xc000
    8774:	f2c4 030f 	movt	r3, #16399	; 0x400f
    8778:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
    877c:	f403 7340 	and.w	r3, r3, #768	; 0x300
    8780:	2b00      	cmp	r3, #0
    8782:	d0f5      	beq.n	8770 <SystemInit+0x1a8>
#else
  LPC_SC->USBCLKCFG = USBCLKCFG_Val;    /* Setup USB Clock Divider            */
#endif

  LPC_SC->PCLKSEL0  = PCLKSEL0_Val;     /* Peripheral Clock Selection         */
    8784:	f24c 0300 	movw	r3, #49152	; 0xc000
    8788:	f2c4 030f 	movt	r3, #16399	; 0x400f
    878c:	f04f 0200 	mov.w	r2, #0
    8790:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
  LPC_SC->PCLKSEL1  = PCLKSEL1_Val;
    8794:	f24c 0300 	movw	r3, #49152	; 0xc000
    8798:	f2c4 030f 	movt	r3, #16399	; 0x400f
    879c:	f04f 0200 	mov.w	r2, #0
    87a0:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac

  LPC_SC->PCONP     = PCONP_Val;        /* Power Control for Peripherals      */
    87a4:	f24c 0300 	movw	r3, #49152	; 0xc000
    87a8:	f2c4 030f 	movt	r3, #16399	; 0x400f
    87ac:	f248 72de 	movw	r2, #34782	; 0x87de
    87b0:	f2c0 4228 	movt	r2, #1064	; 0x428
    87b4:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4

  LPC_SC->CLKOUTCFG = CLKOUTCFG_Val;    /* Clock Output Configuration         */
    87b8:	f24c 0300 	movw	r3, #49152	; 0xc000
    87bc:	f2c4 030f 	movt	r3, #16399	; 0x400f
    87c0:	f04f 0200 	mov.w	r2, #0
    87c4:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
#endif

#if (FLASH_SETUP == 1)                  /* Flash Accelerator Setup            */
  LPC_SC->FLASHCFG  = FLASHCFG_Val;
    87c8:	f24c 0300 	movw	r3, #49152	; 0xc000
    87cc:	f2c4 030f 	movt	r3, #16399	; 0x400f
    87d0:	f243 023a 	movw	r2, #12346	; 0x303a
    87d4:	601a      	str	r2, [r3, #0]
#endif
}
    87d6:	46bd      	mov	sp, r7
    87d8:	bc80      	pop	{r7}
    87da:	4770      	bx	lr
