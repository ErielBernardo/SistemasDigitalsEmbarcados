//*****************************************************************************
//   +--+       
//   | ++----+   
//   +-++    |  
//     |     |  
//   +-+--+  |   
//   | +--+--+  
//   +----+    Copyright (c) 2009 Code Red Technologies Ltd. 
//
// extint_main.c provides an example of how to use External Interrupts
// on the RDB1768 development board. Each time an external interrupt
// is generated by pressing the ISP button, the state of the user LEDs
// (LEDs 2-5) will toggle.
//
//
// Software License Agreement
// 
// The software is owned by Code Red Technologies and/or its suppliers, and is 
// protected under applicable copyright laws.  All rights are reserved.  Any 
// use in violation of the foregoing restrictions may subject the user to criminal 
// sanctions under applicable laws, as well as to civil liability for the breach 
// of the terms and conditions of this license.
// 
// THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
// OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
// USE OF THIS SOFTWARE FOR COMMERCIAL DEVELOPMENT AND/OR EDUCATION IS SUBJECT
// TO A CURRENT END USER LICENSE AGREEMENT (COMMERCIAL OR EDUCATIONAL) WITH
// CODE RED TECHNOLOGIES LTD. 

#include "NXP\LPC17xx\type.h"
#include "NXP\LPC17xx\target.h"
#include "NXP\LPC17xx\LPC17xx.h"

#include "leds.h"

static inline void __enable_irq()	{ asm volatile ("cpsie i"); }
// EINT0 is exception 34
#define EINT0_Interrupt_Enable_Bit (1 << (34 - 16))

volatile unsigned int eint0_count;

#define EINT0_CLR (1 << 0)
#define EINT0_EDGE	0x00000001


void EINT0_IRQHandler (void)
{
	// Clear interrupt
	EXTINT = EINT0_CLR;
	// Increment counter for number of times EINT0 triggered
	eint0_count++;
	// Invert the state of the board's user LEDs
	leds_invert();  
}

int main(void) {

	volatile static int i = 0 ;
	
	// Set up board/processor
	TargetResetInit();

	// *** Setup LEDs ***	
	// Set P1_24, P1_25, P1_28, P1_29 to 00 - GPIO
	PINSEL3	&= (~0x0F0F0000); 
	// Set GPIO - P1_24, P1_25, P1_28, P1_29 - to be outputs
	FIO1DIR |= LED_ALL;

	// *** Setup EINT0 ***	
	// set PINSEL4 [21:20] = 01 for P2.10 as EINT0
	PINSEL4 &= ~(0x11 << 20);
	PINSEL4 |= (0x01 << 20);
	// EINT0 edge trigger
	EXTMODE |= EINT0_EDGE;
	// EINT0 is falling edge by default
	EXTPOLAR &= ~(1 <<0);			
		
	// Turn two of user Leds on
	led_on (LED_2);
	led_on (LED_3);	

	// Setup counter for number of ExtInt0's received
	eint0_count = 0;

	// Turn on interrupts for ExtInt0
	NVIC_ENABLE0 = NVIC_ENABLE0 | EINT0_Interrupt_Enable_Bit;	
	__enable_irq();
	
	// Enter an infinite loop, just incrementing a counter
	// (except when an interrupt is generated)
	while(1) {
		i++ ;
	}
	return 0 ;
}
